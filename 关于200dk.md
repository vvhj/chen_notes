# 关于200dk

200dk是arm架构，一般电脑是x86架构，移动产品是arm架构，arm精简了指令集

## 1. 安装

### 1.1 刷sd卡

使用Etcher工具刷`5.0.2alpha002-catenation-32G-20210618.img`这个版本的镜像系统

ubuntu公共机断网，usb连接200dk：

`ssh HwHiAiUser:192.168.1.2`

密码：

`Mind@123`

切换到root用户，然后换源

###  1.2 **换源**

200dk首先需要换源，不然有些依赖会安装不上：

`vim /etc/apt/sources.list`

更换：

```python
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main multiverse restricted universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main multiverse restricted universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main multiverse restricted universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main multiverse restricted universe
deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main multiverse restricted universe
deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main multiverse restricted universe
deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main multiverse restricted universe
deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main multiverse restricted universe
```

更新：

`sudo apt-get update`

### 1.3 安装依赖和软件

需要连接互联网，参考配置动态ip

1. 依赖（一般用户）：

   onvif

   `pip3 install --upgrade onvif_zeep`

2. 软件（root用户）：

   a. ntpdate

   `apt-get install netpdate`

   运行

   `ntpdate 10.33.2.138`

### 1.4 网站

昇腾官网

https://www.hiascend.com/zh/

昇腾论坛

https://bbs.huaweicloud.com/forum/forum-726-1.html

开发者套件

https://support.huaweicloud.com/Atlas200DK202/index.html

### 1.5 镜像制作

下面，在windows下操作，不能用Linux，否则镜像会小很多。

软件：Win32DiskImager

1. 读卡器和sd卡插入usb

2. window会读取到3个分区

3. 在我的电脑中，查看，选购文件扩展名。新建一个img后缀的空压缩文件（新建一个压缩文件，改名后缀），命名为atlas200

   ![111](/home/chen/Desktop/chen_notes/deepsort/111.png)

4. 打开Win32DiskImager软件

   ![14](/home/chen/Desktop/chen_notes/deepsort/14.png)

   文件内容选取新建的img文件，Device选取读取到的那个分区（不用特意取选取三个分区中的某一个）

5. 点击read，不要手滑点write，等待讲sd卡内容保存到img，也就是镜像文件

   **是read 读取！！！！！！！！！！**

   ![13](/home/chen/Desktop/chen_notes/deepsort/13.png)

6. 利用这个img写入新的sd卡

   **是write 写入！！！！！！！！！！**

   也就同一个软件，文件选img镜像，设备选空sd卡。

   点击write，等待完成；写完后看到新的sd卡会分成3个分区。

### 1.6 window安装ssh

下载安装git，然后从open-ssh仓库，下载编译。



##  2. 部署

###  命令

连接

ssh HwHiAiUser@192.168.1.2

ssh -X -p 22 HwHiAiUser@10.33.27.44

复制

scp -r /home/chen/chen_p/chen_yolo4/detect_rtsp_deepsort.py HwHiAiUser@10.33.27.44:/home/HwHiAiUser/chen_om/

scp -r $HOME/chen_p/chen_yolo4/ydeepsort HwHiAiUser@192.168.1.171:/home/HwHiAiUser/chen_om/

### 部署前准备

1. ntpdate安装

   `sudo apt-get install ntpdate`

2. UTC时间改为CST时间

   cst = utc + 8

   **A方法：**tzselect -> Asia -> China -> Beijing -> 1；重新启动

   **B方法：**vim /etc/profile 末尾添加一行 -> export TZ='CST-8' -> 执行source /etc/profile使文件生效

   然后重新启动

3. 同步时钟服务器

   `ntpdate 10.33.2.138`

4. 检查时间是否正确

   `date`

###  整体流程

**第一步：配置200dk（ubuntu18.04）**

200dk要设定现场静态ip，子网掩码，网关

1. 用type-c线连接主机，主机要提前关闭网络

2. ssh HwHiAiUser@192.168.1.2

3. `ifconfig`查看自己的网卡名称，比如`eth0`

4. `cd /etc/netplan`

5. `ls`查看网络配置文件

6. `vim 01-netplan.yaml`

   ```yaml
   network:
   	version: 2
   	renderer: networkd
   	ethernets:
   		eth0:
   			dhcp4: no
   			addresses: [192.168.202.36/24] #设置本机ip及掩码
   			gateway4: 192.168.202.1 #设置网关，一个网络通向其他网络的ip地址
   			#nameservers:
   			#	addresses: [192.168.202.1] # 设置DNS
   ```

7. sudo netplan apply

**第二步：检测平台调试**

代码部署当现场，需要测试一下视频，看看post是否成功。

1. 点位地址；点位是否绑定服务器
2. post推送地址是否正确，事件推送地址
3. rtsp取流地址是否正确
4. 推送的时间是否正确
5. 推送的事件代码是否正确
6. 用视频测试一下

### 配置动态ip（家里上网）

```python
network:
	version: 2
	renderer: NetworkManger
	ethernets:
		enp3s0:
			dhcp4: true
			addresses: [] 
			optional: true
```

还需要ifconfig查看200dk的mac地址，去路由网站上查询。

### 现场静态ip

**绕城**

```python
network:
	version: 2
	renderer: NetworkManger
	ethernets:
		eth0:
			dhcp4: no
			addresses: [10.33.27.44/25] 
			gateway4: 10.33.27.120
         
        usb0:
            dhcp4: no
            addresses: [192.168.1.2/24]
            gateway4: 192.168.0.1
```

网关：路由器包含很多网关，其中之一就是默认网关。也就是说数据到了路由器后，如果不知道自己下一步怎么走，name他会取默认网关那里报道。起点到终点对应的角路由

### 进程守护

切换到root，配置运行脚本

```bash
vim /etc/crontab
```

最后面添加一行，注意空格

```bash
*/1 * * * * root /home/HwHiAiUser/chen_dsort/syproject.sh >> /home/HwHiAiUser/chen_dsort/syproject.log
```

修改syproject.sh脚本如下

```shell
#!/bin/bash
pwd=Mind@123 # 用户密码

time=$(date +%Y%m%d%H%M%S)
echo "===================检测开始时间："$time"==================="

#project检测
project=`ps -ef | grep mdetect.py| grep -v grep | awk '{print $2}'`  # 此处的main.py改为自己的启动程序名
if [  -z "$project" ]
then
        echo "#project未启动,执行启动命令"
        cd /home/HwHiAiUser/chen_dsort # 进入启动程序main.py的目录下
        nohup python3.6 mdetect.py >roadClose.log 2>&1 &  # 启动进程并将打印日志写入project.log,此处的python main.py需要修改为自己程序的启动方式
else
        echo "#project正常运行"
fi

echo "=========================================================="
```

添加权限

```
chmod 777 syproject.sh
```

查看守护进程是否正常启动，显示正常运行或未启动

```bash
tail -f syproject.log
```

查看程序是否正常运行，会有日志信息

```bash
tail -f roadClose.log
```

### crond周期任务

语法：

1. 5个*来定义时间
2. 分钟-小时-日期-月份-星期几(0~6,0代表星期日) 命令
3. 每分钟可以用 * 和 */1表示

```
# 每星期日晚上23点30分启动httpd进程
30 23 * * 0 service httpd restart
```



系统指定任务

1. vim /etc/crontab



用户定时ntpdate任务

1. 命令crontab -e

   */1 * * * * /usr/sbin/ntpdate ntp.time.server

2. 提示“crontab:installing new crontab”表示成功

3. 查看定时任务crontab -l

### 设置CPU数量

命令：

npu-smi set-t aicpu-config -i id -c chip_id -d value

1. id ：NPU id设备id  `npu-smi info -l`
2. chip_id : 芯片id
3. 芯片的CPU数量，可以设置为2、4、6

`npu-smi set -t aicpu-config -i 0 -c 0 -d 6`



推荐为4：4 或者 6：2



### NPU算力等级

NPU支持4种档位功耗，使用不同散热环境和供电条件。 

* 0：Low
* 1：Middle
* 2 : High
* 3 : Full

`npu-smi set -t nve-level -i 0 -c 0 -d 3`

### 后台运行

nohup python3.6 main.py  &

查查掉框框

 ps -ef|grep python 查看后台运行程序

kill pid 杀掉一个进程



ctrl+c 终止某个进程

ctrl+z 终端进程。fg重启前台启用，bg重新后台启动。

### Gigolo

用这个软件可以连接推流服务器

## 3. 开发

### 3.1 接口流程

首先明白什么是acl（ascend computing language）？acl是整个处理器的最高指挥官。

模型调用接口流程

1. acl初始化（一句话）

   调用acl.init接口初始化acl

2. 运行管理资源申请

   依次申请运行管理资源：Device、Context、Stream

3. 模型加载

4. 模型推理流程

   i. 数据预处理：视频解码，图片缩放

   ii. 推理：同步或异步推理，动态batch等

   ii. 数据后处理

5. 模型卸载

   调用acl.mdl.unload接口卸载模型

6. 运行资源释放

   依次释放运行管理资源：Device、Context、Stream

7. acl去初始化（一句话）

   调用acl.finalize接口实现acl初始化

### 3.2 资源申请

依次申请运行管理资源，包括：Device、Context、Stream。下面介绍显示推荐：

## 4. 业务

常规方法用iou来判断是不是同一个目标。

跟踪方法用id来判断是不是同一个目标。

### 4.1 异常停车

在同一个位置，在一段时间内，检测到的车是同一辆，则认为其是停车异常。

	1. 位置
	2. 一段时间
	3. 求p(是同一辆车|特征1，特征2，特征2.....)

根据先验证知识，p(在同一个位置有同一辆车)是很低很低的，且有很大的不确定成都



问题1：

![m50](/home/chen/Desktop/chen_notes/deepsort/m50.png)

在隧道中，大卡车的检测框不稳定会跳动；导致中心位置变动太大，进而引起一个停车事件多次报警。解决方法：

1. 预期的中心偏移要小，不然移动缓慢的车会检测出来。
2. 加锁面积加大，为检测框的一半
3. 解锁要求检测框内的拥堵概率都是小的才解锁
4. 提高报警阈值



###  4.2 行人

1. 常规

   首先进行来box分为行人和车辆，计算ious矩阵。判断是否有重叠，如果重叠状态=0；如果不重叠，两帧间的iou>0.60，则状态加1。

###  4.5 拥堵

什么是缓行？

路面上车很多的状态下，且车开的很慢



利用状态矩阵，过去30秒一个像素点的占有率

## yaml语法

1. 大小写敏感
2. 使用缩进表示层级关系
3. 禁止使用tab缩进，只能只用空格键
4. 缩进长度没有限制
5. 使用#表示注释
6. 字符串可以不用引号标注

## ssh

安全外壳协议（secure shell），提供安全的远程登录。分为客户端openssh-client和openssh-server。

登录：用户名@ip地址

输入密码

## VLC跨网段

由于公共机有两个网口，VLC取rtsp的时候不知道经过哪个网口。所以要经过如下配置：

1. sudo gedit /etc/rc.local
2. 新打开一个终端，分别复制从第二条开始的命令，运行

ping一下摄像头，通了就好了

## 5. 视频解码

硬件 一个Ascend310NPU+8个CPU+8G内存

**内存不区分**

CUDA中区分host和device内存，host主机由CPU及其内存组成，device设备由GPU及其内存组成。

但是在200dk上不区分Host和Device内存。

**开发应用**

1. 生成om模型，兼容不同的运行环境
2. acl接口编程

[参考文档](https://zhuanlan.zhihu.com/p/377431767)

### 5.1流程

大概分为一下几个步骤：

1. 读取视频H264码流
2. 解码H264，得到一帧帧骨片
3. 略

如果直接使用OpenCV会有问题：

1. OpenCV在200dk上是软件编解码，使用CPU处理视频过于吃力
2. OpenCV画图函数不支持YUV420SP，而一般编解码器输入输出格式都是YUV420SP，使用OpenCV画图需要先将图片转到RGB格式，这也要消耗大量CPU时间
3. OpenCV的putText函数似乎不支持中文

所以使用，ffmpeg和freetype实现相关功能。

### 5.2 软件解码和硬件加密

**软件解码**

H.264的解码压缩率很高，解码运算量很大，因此常规会直接用CPU解码。

**硬件解码**

专门硬件设备进行解码，降低CPU负荷

### 5.3 ffmpeg

专注于视频、音频的解码编码

![m26](/home/chen/Desktop/chen_notes/deepsort/m26.png)

从上图中看出，处理视频主要分为4层：

1. 协议层：HHTP、RTSP等
2. 格式层：MP4等
3. 编码层：H26等
4. 像素层：YUV420，RGB等

在推理应用中，使用ffmpeg处理协议层和格式层，使用DVPP完成编解码，使用NPU在像素层做推理。



**DVPP**

200dk上媒体处理专用硬件单元

1. 创建解码器通道
2. 创建一个线程并绑定到解码器通道
3. 将处理图片的回调函数绑定到解码器通道
4. 使用aclvdecSendFrame接口将H264码流发送给解码器
5. 解码器解码成功后将图片传给用户在第三步3中设置的回调函数

注意点:

1. 解码器只接受Annex-B格式的码流，如果输入是AVCC格式，需要先转成Annex-B格式再传给解码器
2. 不是每次调用aclvdecSendFrame都会立即得到一帧图片，可能多次调用后才能得到一帧图片
3. 用户设置的回调函数必须尽快处理图片，否则会阻塞解码器

### 5.4 VDEC

支持输入格式：

1. H264
2. H265



# OpenCV

## 1. 画图形

img 画在那张图上

Point 坐标

color 线条颜色

thickness 线条宽度

lineType 线条类型

shift 坐标按比例缩小 D/2shift次方



显示文字 cv2.putText

定位为文本框的左下角

## 1. 颜色空间

默认为BGR顺序，而其他软件一般使用RGB，所以需要转换。

```python
import cv2
import numpy as np

p = 'picture.jpg'

img = cv2.imread(p)
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
h, w, _ = img.shape # (高，宽，（B,G,R）)
```

reszie又变了

```python
cv2.resize(p, (10, 20)) # (宽， 高)
```

**a. rtsp取流**

```python
cap = cv2.VideoCapture(source)
if not cap:
    continue
ret = cap.grab()
if ret:
    _, self.imgs = cap.retrieve()
```

### BGR和HSV

**BGR**

人眼有4种感光细胞，红、绿、蓝、黑白

黑 0,0,0

白 255，255，255

蓝 255，0，0

绿 0，255，0

红 0，0，255

不适合做图像处理



**HSV(色调hue， 饱和度saturation，明度value)**

比如我想提取红色，使用BGR可以用一个组合或者一个区间准确描述红色吗？不行，HSV可以。

虽然人眼是靠RGB感知颜色的，但是HSV可以大大简化工作量。

其常用于分割指定颜色的物体。



最重要是，HSV和BGR是同一个物理量的不同表示方法，两者可以转换：

![m30](/home/chen/Desktop/chen_notes/deepsort/m30.png)

![m31](/home/chen/Desktop/chen_notes/deepsort/m31.png)

在GRB中颜色又三个值共同决定，比如黄色是（255，255，0）；而在HSV中，黄色由一个值决定，

=60。

![m25](/home/chen/Desktop/chen_notes/deepsort/m25.jpg)

通俗理解为：

在H一定的情况下，饱和度减少，就是往光谱色中添加白色，光谱所占的比例减少；当饱和度为0，表示光谱色所占的比例为0，导致整个颜色呈现白色。

在H一定的情况下，明度减小，就是往光谱中添加黑色，光谱所占的比例减少；当明度减为0，表示光谱所占的比例为0，导致整个呈现黑色。

 HSV颜色空间更加容易选择颜色，例如，深蓝色V=0.4 S=1 H=240，想要得到浅蓝色，就是加白色V=0.4 S=0.4 H=240

![m32](/home/chen/Desktop/chen_notes/deepsort/m32.png)

![m34](/home/chen/Desktop/chen_notes/deepsort/m34.png)

### 颜色分离

OpenCV中HSV三个分量的范围：

H=[0,179]

S=[0,255]

V=[0,255]



1. 用软件获取颜色BGR值
2. 转换成HSV
3. 确定上下限，比如（h+10, 100, 100）(h-10, 255, 255)

![m36](/home/chen/Desktop/chen_notes/deepsort/m36.jpg)

也就是这个范围，这个要有个直觉！

因为h=0或者h=180都对应红色，所以要定义两个范围：

```python
# 略
```

然后利用改范围进行目标物体提取：

略

### 图像分割

如果图片的颜色特征比强度特征好，可以考虑在H通道上进行自适应二值化处理。



## 1. 降采样和升采样

降采样，采样点数减少。

升采样，插值。



## 1. 插值

缩小图片用区域插值，放大图片用双线性插值。



### 最临近插值

![m44](/home/chen/Desktop/chen_notes/deepsort/m44.jpg)

缩放的位置和原位置是一个映射关系，并且四舍五入。

```python
img = cv2.resize(img, (4, 4), interpolationcv2.INTER_NEAREST
```

###  双线性插值

![m45](/home/chen/Desktop/chen_notes/deepsort/m45.jpg)

缩放位置映射回原图，找到最临近4个点：

1. 先算x轴的加权平均
2. 再算y轴的加权平均

```python
img = cv2.resize(img, (4, 4), interpolationcv2.INTER_LINEAR
```

![m46](/home/chen/Desktop/chen_notes/deepsort/m46.png)



### 面积插值

文档中是这么写的：

> resampeling using pixel area realation. It may be a perferref method for image decimation.

其实上，这个方法在方法和缩小的情况下，做的事是不一样的。



缩小比例是不是整数倍？



是。

比如想把宽和高都缩小为原来三分之一，则区域 = 3 x 3 = 9，算一个平均值就是输出的像素值。



不是。

![m61](/home/chen/Desktop/chen_notes/deepsort/m61.png)

就是小数点的部分也是按比例算，下一个位置上上一个结尾处开始算。



## 1. 膨胀和腐蚀

两者都是针对高亮部分而言的。

1. 膨胀对高亮分布扩张
2. 腐蚀对高亮部分缩小

然后，就是一个算子，取算子内的最大值或者最小值。



## 1. 连接性和连通性

![m70](/home/chen/Desktop/m70.jpg)



## 1. 滤波

两个目的：

1. 提取图像特征
2. 消除噪声

算子同卷积操作



## 1. 重映射与放射变换

**重映射**

把一幅图像中某个位置的像素，放置到另一个图像中指定位置的过程。



**放射变换 affine**

一个放射变换 = 线性变换 + 平移

图像进行放射变换后，二维图像之间的相对位置关系保持不变，平行线依旧是平行线，且直线上点的位置顺序保持不变。



## 1. 热度图



**梯度设置**

热力图的颜色代表人群密度，密度越高，颜色越深。获取每个点的热度方法：

1. 设定半径，计算在半径内人的数量
2. 设定半径，以每个人所在点以此半径设定热度梯度。如果两个点有交叉区域，讲交叉区域的热度叠加。

第一张方法图片大时候比较慢，一般用第二种。



**根据热度分配像素颜色**

根据位置上值的大小，从颜色梯度中提取适合的颜色。



```python
def use_heatmap(image, box_centers):
    import heatmap
    hm = heatmap.Heatmap()
    box_centers = [(i, image.shape[0] - j) for i, j in box_centers]
    
```



**覆盖到原图上**

cv2.addweighted



## 2. 相似度

### 哈希算法

三者都是值越小，相似度越高，取值0-64

**什么是哈希值？**

简单理解为是一段数据的身份证，经过一定的哈希算法，将一段较长的数据映射为较短的数据，它是唯一的。所以经常用它来判断两个文件是否相同，比如验证下载文件是否完整。

**汉明距离**

二进制数据分别为101、111，那么两者汉明距离就是1。

**直方图重合度计算方法**

略



**1. 均值哈希**

速度快，但是不准确。



一般如下步骤：

1. 图片缩小为8*8
2. 转为灰度图
3. 计算灰度图像素的平均值
4. 遍历灰度图，大于平均记为1，否则为0
5. 得到指纹信息，然后计算汉明距离

```python
def aHash(img):
    img = cv2.resize(img, (8, 8))
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # param: s 像素和初值为0
    # param： hash_str hash值初值为‘’
    s = 0
    hash_str = ''
    
    s = img.sum()
    avg = s / 64
    
    # 迭代灰度图，大于平均值+1，小于平均值+0
    
    return hash_str
```

添一句，BGR转灰度是通过加权公式来算的。

**2. 差分哈希**

速度块，精度还可以。





### 直方图

有缺点，它是按照颜色的全局分布来看的，无法描述颜色的局部位置。

缓解方法就是把图片切成等分，然后分别计算相似度，最后综合考虑。

**1. 灰度图计算直方图**

```python
def calculate(image1, image2):
    # 计算图片1的直方图
    # 计算图片2的直方图
    
    # 计算直方图的重合度
    degree = 0
    for i in range(len(hist1)):
        if hist1[i] != hist2[i]:
            degree += (1 - abs(hist1[i] - hist2[i])) / max(hist1[i], hist2[i])
        else:
            degree += 1
    degree /= len(hist1)
    return degree
```

**2. BGR计算直方图**

```python
# 三通道分别算三次
sub = cv2.split(image1)
hist = cv2.calcHist([b], [0], None, [256], [0, 255])
```

## 3 梯度特征

​	什么是梯度？一个多元函数在某点必然有无线多个方向。在这无限多个方向中，导数最大的那一个等于多少（它反映了函数在这点变化率）？它沿什么方向到达？描述这个最大方向导数及其方向的矢量，就是梯度。



### 图像梯度

应用在灰度图上，且目标边缘灰度是最大的，所以常用在边缘检测。

**一阶差分**

1. 离散函数中连续相邻两项之差
2. 图像的梯度相当于2个相邻元素之间的差值



**Sobel算子**

一次卷积运算一个值

![m51](/home/chen/Desktop/chen_notes/deepsort/m51.png)

x差分右边这列 - 左边这列；y差分同理。

```python
x_values = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=5)
```

cv2.CV_64F ? 64F代表一个像素点64位浮点数。

因为导数是有符号的，而原图像像素值大于0。想象一下一个从黑到白的边界，其导数大于0；而从白到黑的边界，其导数小于0。如果原图像的深度是np.uint8，那么所有负值都会截断，也就是说会丢失到边界信息。



**scharr算子**

ksize=-1

### 掩模

掩模用来遮挡局部区域。



**numpy中的掩模**

模块numpy.ma



**opencv中的掩模**

本质就是提取感兴趣区域。Mask就是位图，允许哪些区域拷贝，哪儿区域不拷贝。



画多边形

```python
pts1 = np.array([[10, 5],  [50, 10], [70, 20], [20, 30]], np.int32) # 至少要int32
# pts = pts.reshape((-1, 1, 2)) 尝试过了不用
pts2 = np.array([[10, 5],  [50, 10], [70, 20], [20, 30]], np.int64) # 可以有多个多边形区域
cv2.polylines(img, [pts1, pts2], True, (0, 255, 255))  # 千万不要忘记大括号
cv2.fillPoly(img, [pts], [255, 255, 255])
```

通过腐蚀和膨胀产生Mask

```python
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (10, 10))  # 矩形结构:MORPH_RECT
kernel1 = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 15))  # 椭圆结构:MORPH_ELLIPSE
img = cv2.erode(img, kernel)  # 腐蚀 
img = cv2.dilate(img, kernel)  # 膨胀
```

灰度转BGR

```python
mask = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR) #img是腐蚀膨胀完的图片
ROI = cv2.bitwise_and(mask, oriimg) #oriimg是原始图片
cv2.imshow('ROI',ROI)
```

做与操作，提取到感兴趣区域



**掩膜和掩膜求并集**

```python
and_area = cv2.bitwise_and(mask1, mask2)
```





### sobel算子详解

![m54](/home/chen/Desktop/chen_notes/deepsort/m54.png)

​	4个差分方向

![m53](/home/chen/Desktop/chen_notes/deepsort/m53.png)

​	平均梯度矢量

![m52](/home/chen/Desktop/chen_notes/deepsort/m52.png)

**总结：**

Sobel核心是考虑了4个方向的像素的差分信息，并使用曼哈顿距离取度量这些像素的数据。



### Canny算子

？？？？



### HOG

方向直方图（Histogram of oriented gradient）：统计图像的梯度特征，因为可以检测出这类物体。最终将3通道的彩色图像转换成一定长度的特征向量。



[参考]（https://zhuanlan.zhihu.com/p/75538637）



**梯度计算**

数字图像是离散的，无法直接求导。利用一阶差分来求梯度大小和方向，水平方向和垂直方向的梯度分别是：

![m37](/home/chen/Desktop/chen_notes/deepsort/m37.png)

**单元划分**

![m38](/home/chen/Desktop/chen_notes/deepsort/m38.png)

首选i将图像划分成若干块（Block），每个块由若干单元（cell）组成，每个单元由跟小的像素（pixel）组成，然后在每个单元内对所有像素的梯度方向进行统计。经过实验，把方向分为9个通道效果最好；因此将180度划分为9个区间，每个区间20度。如果像素落在某个区间，就将该像素累加该区间对应的直方图上。

例如，某像素的梯度方向在0~20度，则在0~20度对应的直方图上累加该像素的梯度值。这样每个细胞单元都会得到一个9维的特征向量，其中每一维对应的值是累加的梯度值。

![m39](/home/chen/Desktop/chen_notes/deepsort/m39.png) 

**区块选择**

为了应对光照和形变，梯度需要在局部进行归一化。这个局部区块怎么选择？矩形区块和圆形区块。一个矩形区块由三个参数表示，每个区块多少方格，每个区块多少像素，每个区块多少通道。经过验证，每个方格采用3x3或者9x9效果最好，每个像素选择9个通道效果最好。

**区间归一化**

一个区块有多个方格，也就是有多个特征向量。这一步就是对特征向量进行归一化，用的l2-norm。

**SVM分类器**

用SVM对前面提取的图像特征进行训练。

### Harr

Harr和AdaBoost结合常用于识别人脸，其分为：

1. 边缘特征
2. 线性特征
3. 中心特征
4. 对角线特征

特征模板内有白色和黑色两种矩形，并定义该模板的特征值为白色矩阵像素和 － 黑色矩阵像素和。

Haar特征值反映了图像的灰度变化情况。例如，脸部的一些特征由矩形特征简单的描述，比如眼睛要比脸颊颜色深，鼻梁要比两侧颜色浅。但是矩阵特征只对一些简单的图形结构，如边缘、线段比较敏感。

## 4. 颜色特征

### 颜色矩

颜色信息主要分布在低阶距中，所以用一阶距、二阶距、三阶距足以表达图像的颜色分布，其优点在于特征向量的维数低。

什么是距moment？

*In mathematics, a mment is a specific quantitative measure, used in both mechanics and statistic, of the shape of a set of ponits. If the points represent mass, then the zeroth moment is the total mass, the first moment diviied by the total mass is the center of mass.... If the points reprent probability density, then the zeroth moment is the total probability, the first moment is the mean, the second monents is the variance, the third moment is the skewness...*

1. 均值
2. 方差
3. 斜度

### 颜色直方图

颜色直方图描述不同色彩在整幅图像中所占的比例，而不关心每种色彩所处的空间位置。其特别适合那些难以自动分割的图像。

可以用在不同颜色空间，就是3通道分别算一下直方图。

1. 忽略了图像的空间分布信息
2. 特征向量为256维，维度过高
3. 错误检查

### 主题色

人眼在观察两幅图像时，善于抓住图像的主色，同时忽略次要颜色。下面介绍一种颜色聚类算法：

1. 将RGB颜色空间分为8个区域
2. 求每个区域中心值
3. 计算两个相邻区域的距离



## 5. 纹理特征

### GLCM

灰度共生矩阵法，Gray-level co-occurrence matrix, 通过灰度图像得到其共生矩阵，再通过共生矩阵得到部分特征值，来代表某些纹理特征。共生矩阵能反映图像灰度关于方向、相邻间隔、变化幅度等综合信息。

numpy快速获取灰度共现矩阵：

```python
import fast_glcm
from skimage import data

glcm_mean = fast_glcm.fast_glcm_mean(img)

```

![m40](/home/chen/Desktop/chen_notes/deepsort/m40.png)



1. 均值
2. 标准差
3. 对比度

等等...

### LBP

局部二值模式Local Binary Pattern，是一种用来描述图像局部文理特征的算子，具有旋转不变性和灰度不变性的优点。

![40](/home/chen/Desktop/chen_notes/deepsort/40.png)

中心像素的LBP值，反映了该像素区域周围的纹理信息。



最终，可以把一副灰度图转化成LBP特征图。



然后利用直方图，对LBP进行降维，编程256维度特征向量，输入分类器。

## 6. SURF

加速稳健特征（Speeded Up Robust Feature），尺度不变且有很高计算效率。



**尺度不变特征**

在任何尺度下的物体都能检测到一致的关键点，而且每个特征点都对应一个尺度因子。理想情况下，不同尺度的同一个物体，两个尺度因子的比率等于图像尺度的比率。

![m71](/home/chen/Desktop/chen_notes/deepsort/m71.png)



## 6. SIFT

尺度不变特征变换（scale-invariant feature transform），SURE算法是SIFT算法的加速版。

1. SIFT计算量大
2. 基于浮点计算，所以通常认为比SURE准确



SIFT特征检出用DoG，特征描述用HOG。



### DoG

高斯函数差分（Difference of Guassian），是灰度图增强和角点检测的一种方法。

SIFT特征点的检出主要用了DoG，把图像做不同程度的高斯模糊。平滑的区域肯定变化不大，而边缘、点、角区域变化会很大，这些变化很大的点就是特征点。



**高斯滤波**

图像进行模糊处理

1. 对图像进行二维傅里叶变换变到频域
2. 滤波

中心是低频分量，远离中心是高频分量。公式为：

![m72](/home/chen/Desktop/chen_notes/deepsort/m72.png)

高通滤波器二维图和三维图

![m74](/home/chen/Desktop/chen_notes/deepsort/m74.jpg)

![m75](/home/chen/Desktop/chen_notes/deepsort/m75.jpg)

高频部分会被滤过，低频部分会保留，于是图像就模糊了。



DoG就是在3个不同尺度下，对图像做两次高斯低通滤波然后相减，得到3个不同尺度的DoG图，进而在三维空间中求角点。



获取DoG响应图的方式

![m76](/home/chen/Desktop/chen_notes/deepsort/m76.png)

生成3张响应图

![m77](/home/chen/Desktop/chen_notes/deepsort/m77.jpeg)

然后，依次求中间响应图，每个像素的8领域和上下响应图9*2 = 18，一共8+18=26个像素点的极值。如果这个点在26个点中是最大值和最小值时，则认为该点是图像在该尺度下的一个特征点；最大值标记为1，最小值标记为-1。

![m79](/home/chen/Desktop/chen_notes/deepsort/m79.png)

画在图像上

![m80](/home/chen/Desktop/chen_notes/deepsort/m80.png)

[参考]:https://blog.csdn.net/qq_32211827/article/details/72758090

### HOG

略



### 尺度空间

构建尺度空间目的是为了检测出不同尺寸下都存在的特征点，检测特征点通常用DoG。



**图像金字塔**

同一个图片不同分辨率下得到的一组结果：

1. 对原始图像进行平滑
2. 对处理后的图像进行降采样

降采样后得到一系列不断缩小的图像。



**高斯空间**

通过图像的模糊程度来模拟物体距离的远近，越远越模糊；一幅图像的高斯空间可由和不同的高斯卷积得到



### 步骤

有以下几个步骤组成：

1. 构建尺度空间
2. DoG空间极值检测
3. 删除不好的极值点
4. 求特征点的主方向
5. 特征描述

[参考]: https://www.cnblogs.com/wangguchangqing/p/4853263.html



### 求特征主方向

经过上面步骤已经找到不同尺度下都存在的特征点，为了实现旋转不变性，主要给特征点的方向进行赋值。



### 特征描述

到此步骤，以获取SIFT特征点位置、尺度和方向信息；下面用HOG的方式来描述特征。

![m81](/home/chen/Desktop/chen_notes/deepsort/m81.png)







## 6. ORE

ORE是Oriented Fast and Rotated Brief的简称，可以用来对图像中的关键点快速创建特征向量。其中，Fast和Brief分别是特征检测算法和向量创建算法。其比SIFT快100倍，比SURE算法快10倍。



首先，

ORB会从图像中查找特殊区域，称为关键点。关键点即图像中突出的小区域，比如角点等；它们有着像素急剧变化的特征。

然后，

ORE会为每个关键点计算相应的特征向量。特征向量只包含1和0，1和0的顺序会根据特定关键点和其周围的像素区域而变化。该特征向量表示关键点周围的强度模式，因此多个特征向量可以用来识别更大的区域，甚至图像中的特定对象。



### **特征检测算法FAST**

ORE算法第一步就是查找图像中的关键点。



略



![m96](/home/chen/Desktop/chen_notes/deepsort/m96.png)



### **向量创建算法BRIEF**



BRIEF，Binary Robust Independent Elementary Features的简称，它的作用是根据一组关键点创建二元特征向量。将上面这些特征点转化为特征向量，这些特征向量可以共同表示一个对象。



在BRIEF中，每个特征点由一个二元特征向量描述，该向量一般为128-512位的字符串，其中仅仅包含1和0。

![m97](/home/chen/Desktop/chen_notes/deepsort/m97.png)

因此，使用二元特征向量的一大优势是可以非常搞笑存储在内存中，并且可以快速计算。这使得BRIEF可以在计算资源非常有限的设备上运行。



其如何为每个特征点创建这些二元描述符？首先利用高斯核对图像进行平滑处理，以防对高频点过于敏感。

![m98](/home/chen/Desktop/chen_notes/deepsort/m98.png)

继续

![m93](/home/chen/Desktop/chen_notes/deepsort/m93.png)

一个关键点重复256次，生成一个256维向量，然后转向下一个关键点。



### 缩放不变性和旋转不变性

给定个图像ORB算法首先开始构建图像金字塔。



创建好图像金字塔后，它使用FAST算法从每个级别不同大小的图像中快速找到关键点。于是ORB能够有效发现不同尺寸的关键点，这样ORB实现了部分缩放不变性。



ORB获得图像金字塔每个级别相关的关键点后，其为每个关键点分配一个方向；比如朝左或朝右，取决于该关键点周围的强度如何变化。



**计算关键点的方向**

根据强度形心计算方向

![m99](/home/chen/Desktop/chen_notes/deepsort/m99.png)

在其他层级上计算



### 举例

使用ORB描述符进行对象识别

![m100](/home/chen/Desktop/chen_notes/deepsort/m100.png)

然后使用匹配函数，其目的是匹配两个不同图像的关键点。方法是比较这两个图像的描述符，看它们是否很近似可以匹配。当匹配函数对比两个关键点时，它会根据某种指标得出匹配质量，可以将这个指标看做两个关键点之间的欧几里得距离相似性。



可以有不同的匹配函数，一般对二元描述符来说，通常使用汉明距离，速度非常快。



[参考]:https://www.cnblogs.com/alexme/p/11345701.html



## 6. FAST角点

FAST（加速分割测试获得特征，Features from Accelerated Segment Test），这种算子专门用来快速检测兴趣点，值需要几个像素，就可以判断是否为关键点



特点是不涉及尺度、梯度等复杂运算。



基本思想是，它使用一定领域内像素元的灰度值与中心点比较大小去判断是否为一个角点。



缺点是不具有方向性，尺度不变性。



注意：FAST只是一种特征点检测算法，并不涉及特征点的特征描述。



**角点定义**

若某像素与其周围领域内足够多的像素点相差较大，则该像素点可能是角点。



### 主要步骤

1. 分割测试
2. ID3决策树算法
3. 非极大值抑制



**固定半径圆上的像素进行分割测试（Segment Test）**

​	目的是去除大量的非候选角点。



​	一般是通过半径为3.4 pixel，外围16个像素的圆作为模板

![m91](/home/chen/Desktop/chen_notes/deepsort/m91.png)

然后，计算候选角点

![m92](/home/chen/Desktop/chen_notes/deepsort/m92.png)

一块圆形区域可以分为d、s和b三种类型



**ID3决策树算法来训练角点检测**

选择具有最大信息增益的像素点来判断是否一个角点

![m94](/home/chen/Desktop/chen_notes/deepsort/m94.png)



**非最大抑制**

角点响应函数定义角点强度，于是就可以用非最大抑制来后处理

![m95](/home/chen/Desktop/chen_notes/deepsort/m95.png)



## 6. Harris角点

在图像中搜索有价值的特征点时，使用角点是一种不错的方法。

什么是角点？通常定义为两条边的交点。比如，三角形有三个角，这当然是三角形的特征。严格上来说，角点是指拥有特定特征的图像点，具有某些数学特征。

图像特征类型可以分为三类：

1. 边缘
2. 角点
3. 斑点

角点是个很特殊的存在。如果某一个点在任意方向的一个微小变动都会引起很大的灰度变化，那么可以看做是角点。



**基本思想**

使用一个固定窗口，在图像上进行任意方向的滑动，比较滑动前与滑动后两种情况，窗口中像素的变化程度。如果存在在任意方向上的滑动，都有着较大灰度变化，那么我们可以认为该窗口存在角点。



**数学方法刻画**

![m82](/home/chen/Desktop/chen_notes/deepsort/m82.png)

w是窗口函数，及位置的权重；一般权重都是1，复杂一点就是二元正态分布。



由上述公式，把一个窗口内的像素变化全部加起来。在平滑区域滑动，灰度不会发生变化，则e=0；在纹理复杂的地方滑动，灰度变化会比较剧烈。



进一步。任何一个函数表达式，都可以由泰勒公式展开，以逼近原函数。

![m83](/home/chen/Desktop/chen_notes/deepsort/m83.png)

二次项

![m84](/home/chen/Desktop/chen_notes/deepsort/m84.png)



然后直接用e值来判断角点？不，而是对窗口内每个像素x方向和y方向上的梯度进行统计。



对边缘区域、平坦区域和角点区域这三种情况进行分析：

![m85](/home/chen/Desktop/chen_notes/deepsort/m85.png)

用椭圆表示

![m86](/home/chen/Desktop/chen_notes/deepsort/m86.png)

可以明显看出，角点区域的梯度在x、y方向上都有分布。那是不是可以利用这些特征来判断角点区域呢？

来看M矩阵，如果对各个维度做均值化处理，各个维度的均值=0，其就是协方差矩阵。然后再对M矩阵进行对角化，特征值就是主分量上的方差。如果两个主分量对应的特征值都比较大，说明什么？像素点的梯度比较分散，且梯度变化大，这就符合角点窗口区域的特点。

可以得出下面结论：

1. 特征值都比较大，窗口中含有角点
2. 特征值一个大，一个小，窗口中含有边缘
3. 特征值都比较小，窗口处于平坦区域



**度量角点响应**

![m87](/home/chen/Desktop/chen_notes/deepsort/m87.png)

表达式出来就可以绘制图像了，用R值来区分是不是角点

![m90](/home/chen/Desktop/chen_notes/deepsort/m90.png)



[参考]:https://blog.csdn.net/lwzkiller/article/details/54633670



## 7. 霍夫变换

如何快速识别出图像中的圆和直线？一个非常有效的方法就是霍夫变换，它是图像中识别各种几何形状的基本算法。



**霍夫线变换**

首先一条直线的表示方法有哪些？在直角坐标系下很好理解，在极坐标下面呢？

![m62](/home/chen/Desktop/chen_notes/deepsort/m62.png)



**霍夫圆变换**

用来检测



### 原理

分为直角坐标系和极坐标系



**直角坐标系**

斜率和截距能组成一个参数空间

![m64](/home/chen/Desktop/chen_notes/deepsort/m64.png)

在直角坐标系中的固定一点，其所有斜率和截距的组合在霍夫空间中是一条直线。

![m65](/home/chen/Desktop/chen_notes/deepsort/m65.png)

直角坐标系中有两个点，在霍夫空间中就有两条线，而且肯定会有交点。



但是，直角坐标系有个问题，当直线垂直x轴时，就无法计算了。



所以，真实情况下用极坐标。



**极坐标**

回忆下极坐标

![m66](/home/chen/Desktop/chen_notes/deepsort/m66.png)

极坐标下直线的定义，也是两个参数确定一条直线

![m69](/home/chen/Desktop/chen_notes/deepsort/m69.png)

也可以形成一个参数空间

![m67](/home/chen/Desktop/chen_notes/deepsort/m67.png)

但是在现实中，空间交点往往不会在一点。所以需要分块，分块长度为单位长度；在一个分块内计算交点的数量。

![m70](/home/chen/Desktop/chen_notes/deepsort/m70.png)

显然分块步长对精度有很大影响，一个以单位像素为长度，一个以π/180位长度；而且实际场景中会增加掩膜，来规定兴趣区域，减少计算量。



### 车道检测

1. 转灰度图
2. 高通滤波
3. Canny边缘检测
4. 生成Mask掩膜
5. 基于霍夫变换的直线检测
6. 绘制车道线
7. 图像融合



**Canny边缘检测**

一种信息提取算法，将灰度图最大限度保留信息的下，转换为二值图像；边缘值=255。

```python
cv.Canny(image, low_threhold, high_threshold)
```



**Mask掩膜**

作用是降低计算代价，只对兴趣区域进行计算。

```python
def region_of_interest(image, vertices):
    mask = np.zeros_like(image)
    
    if len(image.shape) > 2:
        channel_count = image.shape[2]
        ignore_mask_color = (255,) * channel_count
    else:
        ignore_mask_color = 255
    
    cv.fillPoly(mask, vertices, ignore_mask_color)
    masked_image = cv2.bitwise(image, mask)
    
    return masked_image
```



**基于霍夫变换的直线检测**

```python
lines = cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), minLineLength=min_line_len, maxLineGap=max_line_gap)
```

* rho: 像素为单位的距离精度
* theta: 以弧度为单位的角度精度
* threshold: 累加阈值
* minLIneLength: 线段最小长度
* maxLineGap: 最大允许断裂长度



**绘制车道先**

把上一步检测到的 直线绘制出来，需要把相邻的线绘制成一条。

![m68](/home/chen/Desktop/chen_notes/deepsort/m68.png)

np.ployfit

```python
# 就是拟合一个直线数据

x = np.linespace(300, 400, 20)
y = x + np.random.random_intergers(5, 20, 20)

# x,y,多项式最高项
# 返回，一个多项式的向量
poly = np.polyfit(x, y, deg=1)
z = np.polyval(poly, x)
```

代码

```python
line_image = np.zeros_like(image)

def draw_lines(image, lines, color=[255, 0, 0], thickness=2):
    
    # right
    right_y_set = []
    right_x_set = []
    right_slope_set = []
    
    # left
    left_y_set = []
    left_x_set = []
    left_slope_set = []
    
    slope_min = .35  # 斜率低阈值
    slope_max = .85  # 斜率高阈值
    middle_x = image.shape[1] / 2  # 图像x轴中间坐标
    max_y = image.shape[0]  # 最大y坐标
    
    for line in lines:
        for x1, y1, x2, y2 in line:
            fit = np.polyfit((x1, x2), (y1, y2), 1)  # 拟合成直线
            slope = fit[0]  # 斜率
            
            if slop_min < np.sbslute(slope) <= slope_max:
                
                # 斜率大于0，线段x坐标在中线右边 -> 存为右车道线
                if slope > 0 and x1 > middle_X and x2 > middle_X:
					right_y_set.append(y1)
                    right_y_set.append(y2)
                    right_x_set.append(x1)
                    right_x_set.append(x2)
                    right_slope_set.append(slope)

                # 同理
                elif slope < 0 and x1 < middle_x and x2 < middle_x:
                    left_y_set.append(y1)
                    left_y_set.append(y2)
                    left_x_set.append(x1)
                    left_x_set.append(x2)
                    left_slope_set.append(slope)
            
    
    # 绘制左车道线
    
    # 根据斜率计算左车道线与图片下方交点作为起点
    
    # 绘制线段
    
    # 绘制右车道线
            
```



**图像融合**

车道线图像和原始图像混合

```python
# 图像1，权重1，图像2，权重2，0
cv2.addWeighted(initial_img, a, img, b, c)
```

讲权重1设为0.8，权重2设为1，则效果是车道线较为明显



取流检测

```python
cap = cv2.VideoCapture(url)
while(cap.isOpened()):
    _, frame = cp.read()
    processed = process_image(frame)
    cv.imshow("image", processed)
    cv.waitKey(1)
```



**进阶**

使用透视变换讲ROI变成鸟蓝图，然后用二次华东窗口对车道进行二次项拟合，然后变回原图，在弯道效果不错。



lanenet车道检测模型



# 机器学习

## 1. 相似性度量

[参考]（https://www.cnblogs.com/heaad/archive/2011/03/08/1977733.html）



就是俗话说计算两个样本的距离：

1. 欧式距离

2. 曼哈顿距离

   街区距离

3. x

4. x

5. x

6. 马氏距离

7. 夹角余弦

8. 汉明距离

9. ？

10. 相关系数

    衡量随机变量x和随机变量y相关程度的一种方法，取值范围[-1, 1]。

11. 信息熵

    信息上不是相似度度量，是衡量分散程度的度量。

### 马氏距离

![m55](/home/chen/Desktop/chen_notes/deepsort/m55.png)

**欧式距离近一定相似？**

显然不是。比如，身高差10cm和体重差10kg完全不同，但在欧式距离中是一样的。



**归一化后的欧式距离就一定相似？**

​	归一化可以消除上述问题，但是数据分布也会影响分类。

​	![m56](/home/chen/Desktop/chen_notes/deepsort/m56.png)

​		上图，两个维度是独立的，x轴的方差大，y轴的方差小。虽然A点和B点和原点距离相同，但是B点是更有可能的数据。

​		怎么办？

​		缩放方差倍数就好了。此时写反差矩阵是单位向量，马氏距离等于欧式距离。

​		但是很多情况下，两个维度是相关的

​		怎么办？

​		PAC组成分析。旋转坐标系，让两个维度独立，然后缩放方差倍数。



**两个维度非独立的情况？**

​	如果维度间不独立，样本点一定是欧式距离近的概率大吗？

![m57](/home/chen/Desktop/chen_notes/deepsort/m57.png)

​	上图，A点、B点和原点的距离相同，显然A点是离群点。

​    

**组成分析怎么算来着？**

知乎

提示一下，x轴上的距离要最大。



1. 计算协方差均值
2. 把协方差矩阵奇异分解
3. 获取主元1，主元2（其实就是新的基）
4. 计算在主元1和主元2上的投影，获取新的坐标



然后就可以计算马氏距离了.....



但是公式怎么来的........



整体就是先标准化，然后PAC。



**感性理解**

![m60](/home/chen/Desktop/chen_notes/deepsort/m60.png)

​	当只有一个变量的时候，很好理解，就是高维的情况下比较难理解。



# python笔记

1. global关键字

   搜索一个变量的规则和我想的一样。但是在函数内部修改全局变量的时候，python会认为它是一个局部变量，而函数中并没有

   的定义和赋值，所以报错会报错。
   
2. 函数传参

   函数的参数到底是传递的一份复制的值，还是对内存的引用？

   答：python中所有**变量**都可以理解为是内存中一个**对象**的“引用”。而对象有两种，“可更改”与“不可更改”对象。在python中，string，tuples和numbers是不可更改对象，而list，dict等则是可修改对象。

   所以，当一个引用传递给函数，函数就自动复制了一份引用。在下面例子中，函数把引用指向了一个不可变对象，当函数返回时，外面的引用是不会改变的。

   ```python
   a = 1
   def fun(x):
       x = 2
       return 2
   ret = fun(a)
   # 结果
   # a = 1
   # ret = 2
   ```

   不过，我们有时确实要在函数内部修改不可变全局变量，怎么办？

   ```python
   a = 1
   def fun(x):
       gobal a 
       x = 3
   ```

   一般全局变量约定使用大写字母







## 2. PyCharm

###  快捷键

shift 换挡

alt 改变

ctrl 控制


* 回到上个代码位置 Shift+Alt+左方向
* 全局搜索 shift+shift
* 找错误点 F2
* 上一次编辑代码的地方 Shift+Alt+Backspace
* 文件内
  1. 下一个方法 Alt+Down
  2. 上一个方法Alt+Up
  3. 当前文件结构 Crtl+F12
* 导航条 Alt+Home
* 加标签 F11

## 3. git分支

与分支相关的三个重要命令：branch、checkout和merge。branch用来创建分支，checkout用来切换不同的分支，merge用来合并分支。

**创建分支**

使用`git branch <branchname>`就可以创建一个分支：

```git
git branch dev
```

创建一个分支，可以理解为创建了一个指针。该指针指向一个commit，而commit中有其parent commit的SHA-1值，从而形成一个分支链条。新建一个分支，没有做任何修改，相当于新的分支和当前分支同时指向同一个commit。

**切换分支**

```git
git checkou dev
```

**合并分支**

在新的分支上对代码做修改，并且进行了新的commit，这样新的分支和原来的master分支就有所不同了。如果需要把新的代码加到master分支中，就要使用`git merge`命令来合并分支。

要合并代码，首先切换到被合并的分支上。如我们要把分支合并到master，则首先要切换到master分支：

```git
git checkout master
```

然后：

```git
git merge dev
```

如果只有两个分支，如果切换到一个分支后并未对原来的分支进行新的commit，那么merge就会变的非常容易，因为是线性的。

## 4. GitHub

加速下载：https://ghproxy.com/

## 5. Cython

用处：

1. 核心逻辑用cpython语言实现块
2. 可以调用c语言编写的库，比如opencv

Cython是基于Python/C API的：

![m33](/home/chen/Desktop/chen_notes/deepsort/m33.png)

配置gcc ubuntu上一般都配置好了

```
sudo apt-get install build-essential
```

安装cython库

```
conda install cython
```

简单的例子

```python
# python
def f(x):
    return x ** 2 - x

# cython
def g(int x):
    return x ** 2 - x
```

块，因为其避免类类型检查。

### 快速入门

创建hello.pyx和setup.py

```python
# file : hello.pyx
def say_hello_to(name):
    print("Hello %s" % name)
```

```python
# file : setup.py
from distutils.core import setup
from Cython.Build import cythonize

setup(name='Hello world app', ext_modules=cythonize("hello.pyx"))
```

编译生成hello.so文件

```python
python setup.py build_ext --inplace
```

调用so

```python
# coding: utf-8
# 这个import会先找hello.py，找不到就会找hello.so
import hello  # 导入了hello.so

hello.say_hello_to('张三')
```

### 调用封装C库

cpython已经帮我们封装好了很多c库

```python
# file: demo.pyx
from libc.math cimport sin
from libc.stdlib cimport atof

def foo(char *s):
    x = atof(s)
    return sin(x)
```

测试一下

```python
# file: test.py
import demo
print(demo.foo("3.1415"))  # 答案约等于0
```

### 调用普通C库

Cyphon是python调用C的桥梁，这一过程叫wrap，中间代码叫wrapper。

![z24](/home/chen/Desktop/chen_notes/deepsort/z24.png)

c代码

```c
// file: queue.h
typedef struct _Queue Queue;
typedef void *QueueValue;
struct _Queue {
    QueueEntry *head;
    QueueEntry *tail;
};
Queue *queue_new(void);
void queue_free(Queue *queue);
```

wrapper

```python
# file: queue.pyx
cdef extern from "queue.h":  # 包含头文件
    ctypedef struct Queue:
        pass
    ctypedef void *QueueValue

    Queue *queue_new()
    void queue_free(Queue *queue)

def foo():
    # 虽然没有实际意义，但这段代码很自嗨，可以看到Cython中完全可以调用C函数
    cdef Queue *q
    q = queue_new()
    queue_free(q)
```

上面代码看出来虽然Cython可以调用C，但作为wrapper还有一个要求是将C语言自然地封装成Python风格，所以还需要下面这段代码让API更加符合面向对象：

```python
cdef class PyQueue:
    cdef Queue *_c_queue

    def __cinit__(self):
        self._c_queue = queue_new()

    def __dealloc__(self):
        if self._c_queue is not NULL:
            queue_free(self._c_queue)
```

编译

```python
# file: setup.py
from distutils.core import setup, Extension
from Cython.Build import cythonize

extension = Extension(
    "queue",
    ["queue.pyx"],
    libraries=["cqueue"]  # 在这边声明需要链接的C库（libcqueue.so）
)

setup(
    ext_modules=cythonize([extension])
)
```

### 语法参考

cpython语法是python的超集

```python
# Python语法
import math  # 导入math.py或math.so或math目录
from math import add as myadd  # Python：导入math.py中的add符号，为避免名字冲突，重命名为myadd
math.add(1, 2)  # 访问math中的add符号
myadd(1, 2)

# 对应的Cython语法
cimport math  # 导入math.pxd
from math cimport add as myadd  # 导入math.pxd中的add符号，为避免名字冲突，重命名为myadd
math.add(1, 2)  # 访问math中的add符号
myadd(1, 2)
```

```python
# Python语法
def foo(a, b):  # 定义foo函数
    c = 0  # 创建Python的int对象
    c = a + b
    return c

# Cython语法
cdef int foo(int a, int b):  # cdef是定义C语言函数，注意该函数不能被Python调用
    cdef int c = 0  # 这是C语言的int变量
    c = a + b
    return c  # 返回C语言的int

# Cython语法
cpdef int foo(int a, int b):  # cpdef定义的函数可以被Python调用
    cdef int c = 0  # C语言的int变量
    c = a + b

    # 返回的是Python的int对象
    # Cython在这里隐式将C语言int变量转为了Python的int对象
    # 因为变量c是基本类型，Cython帮忙转了，如果c是复杂的是不能直接return的
    return c
```

```python
# Python语法
class Person():
    def __init__(self):  # 这是构造函数
        pass

# Cython语法
class Person():
    def __init__(self):  # 和C语言相关的内存分配（如malloc）不能放在这里实现
        pass

    def __cinit__(self):  # 和C语言相关的内存分配（如malloc）要放在这里实现 
        ... = malloc();

    def __dealloc__(self):  # 和C语言相关的内存释放（如free）要放在这里实现 
        free(...);
```

## 6. Usinf C++ in Cython

用Cython来编译C++代码来让python调用

一共五个文件

1. Reactangle.h
2. Rectangle.cpp
3. Rectangle.pxd
4. rect.pyx
5. setup.py

流程概述：

* setup.py编写
* 编写`.pxd`文件用`cdef extern from` blocks和C++ namespace name. In theses blocks:
  * declare classes as `cdef cppclass` blocks
  * declare public names (variables, methods and constructors)
* `cimport` them in one or more extension modules (.pyx files)



[官方文档](https://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html)

### **1. C++代码**

头文件 Reactangle.h

```h
#ifndef RECTANGLE_H
#define RECTANGLE_H

namespace shapes {
    class Rectangle {
        public:
        	int x0, y0, x1, y1;
        	Rectangle();
        	Reactangle(int x0, int y0, int x1, int y1);
        	~Rectangle();
        	init getArea();
        	void getSize(int* width, int* height);
        	void move(int dx, int dy);
    };
}

#endif
```

源文件 Rectangle.cpp

```cpp
#include <iostream>
#include "Rectangle.h"

namespace shapes {
    
    Rectangle::Rectangle () {}
    
	Rectangle::Rectangle (int x0, int y0, int x1, int y1) {
        this->x0 = x0;
        this->y0 = y0;
        this->x1 = x1;
        this->y1 = y1;
    }
    
	Rectangle::~Rectangle () {}
    
    int Reactangle::getArea(){
        return (this->x1 - this->x0) * (this->y1 - this->y0);
    }
    
    void Reactangle::getSize(int *width, int *height){
        (*width) = x1 - x0;
        (*height) = y1 - y0;
    }
    
	void Rectangle::move (int dx, int dy) {
        this->x0 += dx;
        this->y0 += dy;
        this->x1 += dx;
        this->y1 += dy;
    }

}
```

### **2. 编写两个桥梁文件**

Rectangle.pxd文件，Cython和C++的连接

```
cdef extern from "Rectangle.cpp"
	pass

cdef extern from "Rectangle.h" namespace "shapes":
	cdef cppclass Rectangle:
		Rectangle() except +
		Rectangle(int, int, int, int) except +
        int x0, y0, x1, y1
        int getArea()
        void getSize(int* width, int* height)
        void move(int, int)
```

rect.pyx文件，C++和Python的连接

```
# distuils: language = c++

from Rectangle cimport Rectangle

cdef class PyRectangle:
	cdef Rectangle*c_rect
	
	def __cinit__(self, int x0, int y0, int x1, int y1):
        self.c_rect = new Rectangle(x0, y0, x1, y1)
	
    def get_area(self):
        return self.c_rect.getArea()

    def get_size(self):
        cdef int width, height
        self.c_rect.getSize(&width, &height)
        return width, height

    def move(self, dx, dy):
        self.c_rect.move(dx, dy)

    def __dealloc__(self):
        del self.c_rect

def main():
	rec_ptr = new Rectangle(1, 2, 3, 4)  # Instantiate a Rectangle object on the heap
    try:
        rec_area = rec_ptr.getArea()
    finally:
        del rec_ptr  # delete heap allocated object

    cdef Rectangle rec_stack  # Instantiate a Rectangle object on the stack
	
	
	
```

### **3. 编译**

```python
from distutils.core import setup

from Cython.Build import cythonize

setup(ext_modules=cythonize("rect.pyx"))
```

编译命令

```python
python setup.py build_ext --inplace
```

测试

```python
import rect

x0, y0, x1, y1 = 1, 2, 3, 4
rect_obj = rect.PyRectangle(x0, y0, x1, y1)
```

## 7. queue

先进先出，且是线程安全的。

```python
from Queue import Queue

q = Queue(maxsize=5)
for in in range(5):
    q.put(i)
    
q.empty() 是否为空
q.qszie() 大小
q.full() 是否满了
q.get() 先进先出
```

生产者消费者模式，生产者只负责生产，消费者并发消费

```python
from Queue import Queue
import time, threading

q = Queue(maxsize=0)

# 生产者
def product(name):
    count=1
    while True:
        q.put('气球兵{}'.format(count))
        count += 1
        time.sleep(5)
        
# 服务者
def consume(name):
    while True:
        print('{}使用了{}'.format(name, q.get()))
        time.sleep(1)
        # 告诉队列任务已经完成
        q.tak_done()

# 一个生产者，两个消费者
t1=threading.Thread(target=product,args=('wpp',))
t2=threading.Thread(target=consume,args=('ypp',))
t3=threading.Thread(target=consume,args=('others',))
 
t1.start()
t2.start()
t3.start()
```

# socket编程

通信逻辑图：

![m1](/home/chen/Desktop/chen_notes/deepsort/m1.png)

然后，有几点需要注意：

1. python3后，socket传递的都是bytes类型数据。如果是字符串需要先转换下，string.encode()即可；收到bytes数据想转换成字符串，只要bytes.decode()一下就可以。
2. 正常通信时，accpet（）和recv（）方法都是阻塞方法。

参考：

https://www.liujiangblog.com/course/python/76

## 1. 编程思路

下面有的协议有TCP和UDP两种，一般只操作TCP。

**服务端：**

1. 创建socket，socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()

   第一个变量是IPv4的意思

2. 开始监听

3. 进入循环，不断接受客户端的连接请求 s.accept()

4. 接受传来的数据或者发送数据给对方 s.recv(), s.sendall()

5. 关闭

**客户端：**

	1. 创建socket，socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
	2. 接受传来的数据或者发送数据给对方s.recv(), s.sendall()
	3. 关闭

## 2. 代码

**服务端：**

```python
import socket

ip_port = ('127.0.0.1', 9999)

sk = socket.socket()
sk.bind(ip_port)
sk.listen(5) # 监听连接请求
print('启动socket服务，等待客户端连接...')
conn，address = sk.accept() # 阻塞
while True: # 死循环
    client_data = conn.rev(1024).decode()
    if client_data == 'exit':
        exit('结束通信')
    print('来自%s的客户端向你发来信息：%s'% (address, client_data))
    # 返回信息给客户端
    conn.sendall('服务端已经收到您的信息'.encode())
conn.close()
```

**服务端加线程**：

```python
import socket
import threading

def link_handler(link, client):     
    """
    该函数为线程需要执行的函数，负责具体的服务器和客户端之间的通信工作
    :param link: 当前线程处理的连接
    :param client: 客户端ip和端口信息，一个二元元组
    :return: None
    """
    print("服务器开始接收来自[%s:%s]的请求...." % (client[0], client[1]))
    while True:     # 利用一个死循环，保持和客户端的通信状态
        client_data = link.recv(1024).decode()
        if client_data == "exit":
            print("结束与[%s:%s]的通信..." % (client[0], client[1]))
            break
        print("来自[%s:%s]的客户端向你发来信息：%s" % (client[0], client[1], client_data))
        link.sendall('服务器已经收到你的信息'.encode())
    link.close()
    
ip_port = ('127.0.0.1', 9999)
sk = socket.socket()            # 创建套接字
sk.bind(ip_port)                # 绑定服务地址
sk.listen(5)                    # 监听连接请求

print('启动socket服务，等待客户端连接...')

while True:     # 一个死循环，不断的接受客户端发来的连接请求
    conn, address = sk.accept()  # 等待连接，此处自动阻塞
    # 每当有新的连接过来，自动创建一个新的线程，
    # 并将连接对象和访问者的ip信息作为参数传递给线程的执行函数
    t = threading.Thread(target=link_handler, args=(conn, address))
    t.start()
```





**客户端：**

```python
import socket

ip_port = ('127.0.0.1', 9999)
s = socket.socket()
s.connect(ip_port)

# 死循环，不断接受用户输入，并发送给服务器
while True:
    inp = input("请输入要发送的信息：").strip()
    if not inp:
        continue
    s.sendall(inp.encode())
    
    if inp == 'exit':
        print('通信结束')
        break
    
    server_reply = s.recv(1024).decode()
    print(server_reply)
    
s.close()
```

## 3.  json

```python
import json

data = {
    'name': 'chen',
    'age': 32,
    'vip': True,
    'address:': {'x1', 'x2'}
}

# 序列化
json_str = json.dumps(data)

# 反序列化
user_dic = json.loads(json_str)

# 输出到文件
with open('xx.json', 'w', encoding='utf-8') as f:
    json.dump(user_dic, f, ensure_ascii=False, indent=4)

# 读文件
with open('xx.json', 'r', encoding='utf-8') as f:
    ret_dic = json.load(f)
```

## 4. 地址已经使用

当客户端向服务端发送消息后，关闭连接后，如果马上再去运行服务端，会提示错误：

```
socket.error: [Errno 98] Address already in use
```

这是因为在TCP/IP终止连接的四次握手中，当最后的ACK回复发出后，有个2MSL的时间等待，MSL指一个片段在网络中最大的存活时间，这个时间一般是30秒，所以基本上过60秒后就可以重新连接！

为什么要等待2MSL？是因为在最后发出ACK回复后，发送方不能确认ACK是否被另一端正常收到，如果另一端没有收到ACK回复的话，将会在1MSL后再次发送FIN片段。所以说发送方等待2MSL时间，也就是刚好它发ACK回复和对方发送FIN片段的时间，如果此时间内都没有再次收到FIN片段的话，发送方就假设对方已经正常接收到了ACK回复，此时它就会正常关闭连接！

如果需要重用的话：

```
self.recSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
self.recSocket.settimeout(CHECK_TIMEOUT)
# 这句
self.recSocket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) 
self.recSocket.bind(('', UDP_PORT))  
```

## 5. send和sendall

两种方式都可以用来发送一条完整的数据。

```python
data = "xxxxxxx"
block = 0
block_size = 5 # 规定一次发多少数据

# 1
while True:
    obj.sendall(data.encode())
    break

# 2
while True:
    obj.send(data[block:block+block_size].encode())
    if block > len(data):
        break
    else:
        block += block_size
```

**send()**

使用`send()`进行发送的时候，`Python`将内容传递给系统底层的`send`接口,也就是说，`Python`并不知道这次调用是否会全部发送完成，比如`MTU`是1500，但是此次发送的内容是2000，那么除了包头等等其他信息占用，发送的量可能在1000左右，还有1000未发送完毕

但是，`send()`不会继续发送剩下的包，因为它只会发送一次，发送成功之后会返回此次发送的字节数，如上例，会返回数字1000给用户，然后就结束了

如果需要将剩下的1000发送完毕，需要用户自行获取返回结果，然后将内容剩下的部分继续调用`send()`进行发送

**sendall**

`sendall()`是对`send()`的包装，完成了用户需要手动完成的部分，它会自动判断每次发送的内容量，然后从总内容中删除已发送的部分，将剩下的继续传给`send()`进行发送；

## 6. 补充知识

**MTU（Maximum Transmission Unit）最大传输单元**

是指通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。

以以太网传送`IPv4`报文为例。`MTU`表示的长度包含IP包头的长度，如果IP层以上的协议层发送的数据报文的长度超过了`MTU`，则在发送者的IP层将对数据报文进行分片，在接收者的IP层对接收到的分片进行重组。

**TCP可靠传输**

* 应用数据被分割为`TCP`认为最适合发送的数据块。
* 流量控制，TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端接受缓冲区所能接纳的数据。

# Ubuntu

## 1. 文件夹

创建 mkdir xx

重命名 mv x1 x2

## 2. Shell脚本

## 3. 命令

1. sudo权限命令`visudo`
2. 找到python装在哪里 `which python`
3. ctrl+e 光标到行尾
4. ctrl+l 清屏
5. ctrl+c 中断当前进程
6. pwd 显示当前所在目录
7. ctrl+z 暂停当前进程到后台
8. ifconfig



1. ls

2. pwd   

   * print working directory

3. cd

   * cd ~ 进入家目录
   * cd .. 进入上级目录

4. touch

5. mkdir

6. rm

   * rm -r 递归删除
   * rm -rf 强制删除

7. clear

8. tab 自动补全

9. cp

   cp -r 复制目录

10. mv

    mv 源文件 目标位置



常用目录

1. bin 命令
2. etc 配置
3. home 普通用户家目录
4. root 超级用户家目录
5. lib 系统库



权限位：

-rw-r--r--. 1 root root 44736 7月  18 00:38 install.log

第一位：

-- 普通文件

d 目录

l 连接文件

(前三位=属主权限u  中间三位=属组权限g  其他人权限o)

r 读 4

w 写 2 

x 执行 1



chmod 777 aa 更改文件权限

find / -name xxxx

grep -i "root" /etc/passwd 忽略大小写，查询找符合条件的字符串

管道符 |

命令1|命令2

cat 文件|grep 'sss'  提取所有包含sss的行











